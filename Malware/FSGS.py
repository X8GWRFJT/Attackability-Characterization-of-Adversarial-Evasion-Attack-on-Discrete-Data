import time
import pickle
import torch
import torch.nn as nn
from ThreeAttackAlgorithms import rnn_tools
from ThreeAttackAlgorithms import rnn_model
from torch.autograd import Variable
from copy import deepcopy
import os
import numpy as np
from math import pow
from itertools import combinations


TAU = 0.5
MODEL_TYPE = 'nonsub'
SECONDS = 3600

TITLE = '=== ' + MODEL_TYPE + ' target prob = ' + str(TAU) + ' time = ' + str(SECONDS) + ' ==='

NUM_ATTACK_SAMPLES = 1000

log_f = open('./Logs/Prim_%s_t=%s_s=%d.bak' % (MODEL_TYPE, str(TAU), SECONDS), 'a')

class Attacker(object):
    def __init__(self, options, emb_weights):
        print("Loading pre-trained classifier...", file=log_f, flush=True)

        self.model = rnn_model.LSTM(options, emb_weights)

        if MODEL_TYPE == 'sub':
            self.model.load_state_dict(torch.load('./Classifiers/Submodular_lstm.7')) # abs
        elif MODEL_TYPE == 'nonsub':
            self.model.load_state_dict(torch.load('./Classifiers/Nonsubmodular_lstm.7')) # positive and negative
        self.model.eval()

        self.criterion = nn.CrossEntropyLoss()

    def classify(self, funccall):

        model_input, weight_of_embed_codes = self.input_handle(funccall)

        logit = self.model(model_input, weight_of_embed_codes)

        pred = torch.max(logit, 1)[1].view((1,)).data.numpy()

        prob = logit[0][pred]

        return pred, prob

    def input_handle(self, funccall):
        funccall = [funccall]
        t_diagnosis_codes = rnn_tools.pad_matrix(funccall)
        model_input = deepcopy(t_diagnosis_codes)
        for i in range(len(model_input)):
            for j in range(len(model_input[i])):
                idx = 0
                for k in range(len(model_input[i][j])):
                    model_input[i][j][k] = idx
                    idx += 1

        model_input = Variable(torch.LongTensor(model_input))
        return model_input, torch.tensor(t_diagnosis_codes)

    def eval_Cy(self, funccall, pos, greedy_set, greedy_set_max_Cy, orig_label):
        best_Cy = greedy_set_max_Cy
        best_temp_person = deepcopy(funccall)
        candidate_lists = []

        # candidate_lists contains all the non-empty subsets of greedy_set
        if greedy_set:
            for i in range(1, len(greedy_set) + 1):
                subset1 = combinations(greedy_set, i)
                for subset in subset1:
                    candidate_lists.append(list(subset))

            for can in candidate_lists:
                can.append(pos)
        else:
            candidate_lists.append([pos])

        for can in candidate_lists:

            temp_funccall = deepcopy(funccall)

            for position in can:
                visit_idx = position[0]
                code_idx = position[1]

                temp_funccall[visit_idx] = code_idx

            model_input, weight_of_embed_codes = self.input_handle(temp_funccall)
            logit = self.model(model_input, weight_of_embed_codes)

            Cy = logit[0][orig_label]

            if 1-Cy > best_Cy:
                best_Cy = 1-Cy
                best_temp_person = deepcopy(temp_funccall)

        return best_Cy, best_temp_person

    def attack(self, funccall, y):
        st = time.time()
        success_flag = 1

        one_hot_codes = np.zeros((len(funccall), 1104))
        for i in range(len(funccall)):
            one_hot_codes[i][funccall[i]] = 1

        orig_pred, orig_prob = self.classify(funccall)
        print(orig_pred, orig_prob, file=log_f, flush=True)

        pred, pred_prob = orig_pred, orig_prob

        if not (pred == y or pred_prob < TAU):
            success_flag = 0
            return {}, funccall, pred_prob, 0, success_flag, 0

        best_Cy = 1 - pred_prob

        iteration = 0

        n_change = 0

        greedy_set = set()
        greedy_set_visit_idx = set()
        greedy_set_best_temp_funccall = []

        greedy_set_max_Cy = best_Cy

        while pred == y or best_Cy < TAU:
            best_pos = 0
            iteration += 1
            best_temp_Cy = -1

            for visit_idx in range(len(one_hot_codes)):
                if visit_idx in greedy_set_visit_idx: continue
                for code_idx in range(1, len(one_hot_codes[visit_idx])):

                    if (time.time() - st) > SECONDS and (pred == y or pred_prob < TAU):
                        print("===== Time out! Attack Fail =====", file=log_f, flush=True)
                        success_flag = -1
                        break

                    pos = (visit_idx, code_idx)
                    if pos in greedy_set: continue
                    if code_idx == funccall[visit_idx]: continue

                    eval_funccall = deepcopy(funccall)
                    Cy, temp_funccall = self.eval_Cy(eval_funccall, pos, greedy_set, greedy_set_max_Cy, y)

                    if Cy > best_temp_Cy:
                        best_temp_Cy = Cy
                        best_pos = pos
                        if best_temp_Cy > best_Cy:
                            best_Cy = best_temp_Cy
                            best_temp_funccall = deepcopy(temp_funccall)

                if (time.time() - st) > SECONDS and (pred == y or pred_prob < TAU):
                    print("===== Time out! Attack Fail =====", file=log_f, flush=True)
                    success_flag = -1
                    break

            if best_pos:
                greedy_set.add(best_pos)
                greedy_set_visit_idx.add(best_pos[0])
                greedy_set_max_Cy = best_Cy
                greedy_set_best_temp_funccall = best_temp_funccall

            #         if Cy > best_Cy:
            #             best_Cy = Cy
            #             best_pos = pos
            #             best_temp_funccall = deepcopy(temp_funccall)
            #
            # if best_pos:
            #     greedy_set.add(best_pos)
            #     greedy_set_visit_idx.add(best_pos[0])
            #     greedy_set_max_Cy = best_Cy
            #     greedy_set_best_temp_funccall = best_temp_funccall
            # else:
            #     success_flag = 0
            #     print("====== Fail ======")
            #     break

            if best_Cy > 0.5:
                pred = 1 - y

            # if (time.time() - st) > SECONDS and (pred == y or pred_prob < TAU):
            #     print("===== Time out! Attack Fail =====", file=log_f, flush=True)
            #     success_flag = -1
            #     break

        for i in range(len(greedy_set_best_temp_funccall)):
            if greedy_set_best_temp_funccall[i] != funccall[i]:
                n_change += 1

        if len(greedy_set) == 0: success_flag = 0

        return greedy_set, greedy_set_best_temp_funccall, best_Cy, n_change, success_flag, iteration


def main(emb_weights, training_file, validation_file,
                                       n_diagnosis_codes, n_labels,
                                       batch_size, dropout_rate,
                                       L2_reg, n_epoch, log_eps, n_claims, visit_size, hidden_size,
                                       model_name):
    options = locals().copy()
    print("Loading dataset...", file=log_f, flush=True)
    test = rnn_tools.load_data(validation_file)

    n_samples = NUM_ATTACK_SAMPLES

    attacker = Attacker(options, emb_weights)

    n_success = 0
    n_fail = 0

    total_node_change = 0

    n_iteration = 0

    saving_time = {}

    attack_code_dict = {}

    # # ****** #
    # file1 = './AttackCodes/codes_Prim_nonsub_t=0.99999999_s=3600.pickle'
    #
    # attack_code_dict = pickle.load(open(file1, 'rb'))
    #
    # file2 = './Each_TimeNumber/time_Prim_nonsub_t=0.99999999_s=3600.pickle'
    #
    # saving_time = pickle.load(open(file2, 'rb'))
    # # ****** #

    for i in range(n_samples):
        print("-------- %d ---------" % (i), file=log_f, flush=True)

        sample = test[0][i]

        y = test[1][i]

        print('* Processing:%d/%d person' % (i, n_samples), file=log_f, flush=True)

        print("* Original: " + str(sample), file=log_f, flush=True)

        print("  Original label: %d" % (y), file=log_f, flush=True)

        st = time.time()
        greedy_set, greedy_set_best_temp_person, best_Cy, num_changed, success_flag, iteration = attacker.attack(sample,
                                                                                                                 y)

        et = time.time()
        all_t = et - st

        if success_flag == 1:
            n_success += 1
            n_iteration += iteration
            total_node_change += num_changed
            saving_time[i] = all_t
            attack_code_dict[i] = list(greedy_set)
        elif success_flag == -1:
            n_fail += 1

        print("* Result: ", file=log_f, flush=True)
        print(greedy_set, file=log_f, flush=True)
        print(greedy_set_best_temp_person, file=log_f, flush=True)
        print(best_Cy, file=log_f, flush=True)

        print("  Nnumber of changed codes: %d" % (num_changed), file=log_f, flush=True)

        print("  Number of iterations for this: " + str(iteration), file=log_f, flush=True)

        print(" Time: " + str(all_t), file=log_f, flush=True)

        print("* SUCCESS Number NOW: %d " % (n_success), file=log_f, flush=True)
        print("* Failure Number NOW: %d " % (n_fail), file=log_f, flush=True)

        if n_success:
            print("  Average Number of success changed codes: " + str(float(total_node_change) / float(n_success)), file=log_f, flush=True)
            print("  Average Number of success iterations: " + str(float(n_iteration) / float(n_success)), file=log_f, flush=True)

        if i % 20 == 0:
            pickle.dump(attack_code_dict, open('./AttackCodes/codes_Prim_%s_t=%s_s=%d.pickle' % (MODEL_TYPE, str(TAU), SECONDS), 'wb'))
            pickle.dump(saving_time, open('Each_TimeNumber/time_Prim_%s_t=%s_s=%d.pickle' % (MODEL_TYPE, str(TAU), SECONDS), 'wb'))

    pickle.dump(attack_code_dict,
                open('./AttackCodes/codes_Prim_%s_t=%s_s=%d.pickle' % (MODEL_TYPE, str(TAU), SECONDS), 'wb'))
    pickle.dump(saving_time,
                open('Each_TimeNumber/time_Prim_%s_t=%s_s=%d.pickle' % (MODEL_TYPE, str(TAU), SECONDS), 'wb'))

    print("--- Total Success Number: " + str(n_success) + " ---", file=log_f, flush=True)
    print("--- Total Attack Success Rate: " + str(float(n_success) / float(n_success+n_fail)), file=log_f, flush=True)

    print(TITLE, file=log_f, flush=True)

    print(TITLE)


if __name__ == '__main__':
    print(TITLE)
    print(TITLE, file=log_f, flush=True)
    # parameters
    batch_size = 5
    dropout_rate = 0.2
    L2_reg = 0.001  # 0.001
    log_eps = 1e-8
    n_epoch = 50
    n_labels = 3  # binary classification
    visit_size = 70
    hidden_size = 70
    n_diagnosis_codes = 1104
    n_claims = 504

    # use_gpu = True
    model_name = 'lstm'

    training_file = './SourceData/tri_sub0.01_training_malware_index_data.pickle'
    validation_file = './SourceData/tri_sub0.003_validation_malware_index_data.pickle'

    emb = torch.load("./SourceData/PretrainedEmbedding1104.0", map_location=torch.device('cpu'))['embeddings.weight']

    emb_weights = torch.tensor(emb, dtype=torch.float)

    main(emb_weights, training_file, validation_file,
                n_diagnosis_codes, n_labels,
                batch_size, dropout_rate,
                L2_reg, n_epoch, log_eps, n_claims, visit_size, hidden_size,
                model_name)

